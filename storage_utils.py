
import math
import matplotlib.pyplot as plt
import csv
import pickle

def get_pickle(name):
    """
    Get the data from the pickle file
    :param name: name of the file containing a pickled object
    :return: the object pickled in the file
    """
    fin = open(name, 'rb')
    ret_v = pickle.load(fin)
    fin.close()
    return ret_v

def write_pickle(name, data):
    """
    Write the data to a pickle file
    :param name: Name of the file into which the pickle is to be written
    :param data: Object to be pickled
    :return: None
    """
    fout = open(name, 'wb')
    pickle.dump(data, fout)
    fout.close()
    return None



def totals_by_role(use_l):
    """
    Get the total data usage by role, including a grand total labelled 'All'
    :param use_l: A list of the form generated by extract_data
    :return: A dictionary indexed by role with values the total data usage for that role
    """
    totals = {'All': 0}

    for d in use_l:
        if d[2] not in totals:
            totals[d[2]] = 0
        totals[d[2]] += d[1]
        totals['All'] += d[1]

    return totals

def bin_data(d_l):
    counts = {}
    for row in d_l:
        # Get the second value in the row
        value = float(row[3])

        # Get the order of magnitude of the value
        if value == 0:
            order_of_magnitude = -4.0
        else:
            order_of_magnitude = int(math.floor(math.log10(value)))
            if order_of_magnitude < -3:
                order_of_magnitude = -4

        # Increment the count for the order of magnitude
        if order_of_magnitude not in counts:
            counts[order_of_magnitude] = {}
        if row[2] not in counts[order_of_magnitude]:
            counts[order_of_magnitude][row[2]] = 0

        counts[order_of_magnitude][row[2]] += 1

    return counts

def print_results(counts):
    # Print the counts
    indexes = sorted(counts.keys())
    for i in indexes:
        for j in counts[i].keys():
            print('Order of magnitude: {}, Classification {} Count: {}'.format(i, j, counts[i][j]))

def plot_values(data):
    # Extracting the data for plotting
    x = list(data.keys())
    label_s = set()
    for i in x:
        label_s = label_s.union(set(data[i].keys()))
    labels = list(label_s)

    for i in x:
        for l in labels:
            if l not in data[i]:
                data[i][l] = 0
    counts = [[data[i][label] for label in labels] for i in x]

    # Plotting the bar graph
    bar_width = 0.2  # Width of each bar
    opacity = 0.8    # Opacity of the bars

    fig, ax = plt.subplots()
    for i in range(len(labels)):
        plt.bar([val + i * bar_width for val in x], [count[i] for count in counts], bar_width,
                alpha=opacity, label=labels[i])

    plt.xlabel('Data Stored (Terabytes)')
    plt.ylabel('Number of Users')
    plt.title('Data Usage by Number of Users')
    plt.xticks([val + bar_width for val in x], x)
    plt.legend()
    plt.tight_layout()
    plt.show()


def convert_name(name):
    # Split the name into last name and first name
    last_name, first_name = name.split(", ")

    # Remove any leading or trailing spaces
    last_name = last_name.strip()
    first_name = first_name.strip()

    # Concatenate the first name and last name with a space in between
    converted_name = ' '.join([first_name, last_name])

    return converted_name

def build_name_set(from_list, name_index):
    ret_s = set()
    for l in from_list:
        ret_s.add(l[name_index])
    return ret_s

def build_role_dict(from_list, name_index, role_index):
    ret_d = {}
    for l in from_list:
        ret_d[l[name_index]] = l[role_index]
    return ret_d

